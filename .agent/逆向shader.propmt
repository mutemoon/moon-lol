这是 autoagents 的例子

use std::sync::Arc;

use autoagents::core::agent::memory::SlidingWindowMemory;
use autoagents::core::agent::prebuilt::executor::{ReActAgent, ReActAgentOutput};
use autoagents::core::agent::task::Task;
use autoagents::core::agent::{AgentBuilder, AgentDeriveT, AgentOutputT, DirectAgent};
use autoagents::core::error::Error;
use autoagents::core::tool::{ToolCallError, ToolInputT, ToolRuntime, ToolT};
use autoagents::llm::backends::openai::OpenAI;
use autoagents::llm::builder::LLMBuilder;
use autoagents::llm::LLMProvider;
use autoagents_derive::{agent, tool, AgentHooks, AgentOutput, ToolInput};
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Serialize, Deserialize, ToolInput, Debug)]
pub struct AdditionArgs {
    #[input(description = "Left Operand for addition")]
    left: i64,
    #[input(description = "Right Operand for addition")]
    right: i64,
}

#[tool(
    name = "Addition",
    description = "Use this tool to Add two numbers",
    input = AdditionArgs,
)]
struct Addition {}

#[async_trait]
impl ToolRuntime for Addition {
    async fn execute(&self, args: Value) -> Result<Value, ToolCallError> {
        println!("execute tool: {:?}", args);
        let typed_args: AdditionArgs = serde_json::from_value(args)?;
        let result = typed_args.left + typed_args.right;
        Ok(result.into())
    }
}

/// Math agent output with Value and Explanation
#[derive(Debug, Serialize, Deserialize, AgentOutput)]
pub struct MathAgentOutput {
    #[output(description = "The addition result")]
    value: i64,
    #[output(description = "Explanation of the logic")]
    explanation: String,
    #[output(description = "If user asks other than math questions, use this to answer them.")]
    generic: Option<String>,
}

#[agent(
    name = "math_agent",
    description = "You are a Math agent",
    tools = [Addition],
    output = MathAgentOutput,
)]
#[derive(Default, Clone, AgentHooks)]
pub struct MathAgent {}

impl From<ReActAgentOutput> for MathAgentOutput {
    fn from(output: ReActAgentOutput) -> Self {
        let resp = output.response;
        if output.done && !resp.trim().is_empty() {
            // Try to parse as structured JSON first
            if let Ok(value) = serde_json::from_str::<MathAgentOutput>(&resp) {
                return value;
            }
        }
        // For streaming chunks or unparseable content, create a default response
        MathAgentOutput {
            value: 0,
            explanation: resp,
            generic: None,
        }
    }
}

pub async fn simple_agent(llm: Arc<dyn LLMProvider>) -> Result<(), Error> {
    let sliding_window_memory = Box::new(SlidingWindowMemory::new(10));

    let agent_handle = AgentBuilder::<_, DirectAgent>::new(ReActAgent::new(MathAgent {}))
        .llm(llm)
        .memory(sliding_window_memory)
        .build()
        .await?;

    println!("Running simple_agent with direct run method");

    let result = agent_handle.agent.run(Task::new("What is 1 + 1?")).await?;
    println!("Result: {:?}", result);
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    // Check if API key is set
    let api_key = std::env::var("OPENAI_API_KEY").unwrap_or("".into());

    // Initialize and configure the LLM client
    let llm: Arc<OpenAI> = LLMBuilder::<OpenAI>::new()
        .api_key(api_key) // Set the API key
        .model("gpt-4o") // Use GPT-4o-mini model
        .max_tokens(512) // Limit response length
        .temperature(0.2) // Control response randomness (0.0-1.0)
        .build()
        .expect("Failed to build LLM");

    let _ = simple_agent(llm).await?;
    Ok(())
}

--- VSCODE-MULTI-EDIT-FILEPATH: d:\Users\admin\workspace\moon-lol\assets\shaders_extract\environment\unlit_decal\vs\MULT_PASS.vert ---
#version 410

vec3 _40 = vec3(0.0);

struct UniformsVertex
{
    mat4 VIEW_PROJECTION_MATRIX;
    vec4 FOG_OF_WAR_PARAMS;
    vec4 FOG_OF_WAR_ALWAYS_BELOW_Y;
    vec4 FOW_HEIGHT_FADE;
    mat4 DECAL_WORLD_MATRIX;
    mat4 DECAL_WORLD_TO_UV_MATRIX;
    vec4 DECAL_PROJECTION_Y_RANGE;
    mat4x3 vParticleUVTransformMult;
};

uniform UniformsVertex _UniformsVertex;

layout(location = 0) in vec3 ATTR0;
layout(location = 0) out vec3 TEXCOORD0;
layout(location = 1) out vec2 TEXCOORD1;
layout(location = 2) out vec2 TEXCOORD2;

void main()
{
    precise vec4 _10 = _UniformsVertex.DECAL_WORLD_MATRIX * vec4(ATTR0, 1.0);
    precise vec4 _11 = _UniformsVertex.VIEW_PROJECTION_MATRIX * _10;
    vec4 _55 = _UniformsVertex.DECAL_WORLD_TO_UV_MATRIX * _10;
    vec2 _56 = _55.xz;
    float _58 = 1.0 - _55.z;
    _56.y = _58;
    vec3 _60 = vec3(_56.x, _56.y, _40.z);
    float _64 = abs(ATTR0.y - _UniformsVertex.DECAL_PROJECTION_Y_RANGE.x);
    vec3 _78 = vec3(0.0);
    if (_64 <= _UniformsVertex.DECAL_PROJECTION_Y_RANGE.y)
    {
        vec3 _71 = _60;
        _71.z = 1.0;
        _78 = _71;
    }
    else
    {
        vec3 _77 = _60;
        _77.z = 1.0 - ((_64 - _UniformsVertex.DECAL_PROJECTION_Y_RANGE.y) / _UniformsVertex.DECAL_PROJECTION_Y_RANGE.z);
        _78 = _77;
    }
    gl_Position = _11;
    TEXCOORD0 = _78;
    TEXCOORD1 = (_UniformsVertex.vParticleUVTransformMult * vec4(_55.x, _58, 1.0, 0.0)).xy;
    TEXCOORD2 = ((_10.xz * _UniformsVertex.FOG_OF_WAR_PARAMS.xy) + _UniformsVertex.FOG_OF_WAR_PARAMS.zw).xy;
}

输入一个存放 2 的 n 次方个 shader 文件的文件夹，以这 4 个文件为例，生产中可能会有 4096 个文件，后缀可能全为 .vert 或 .frag
例子：

--- VSCODE-MULTI-EDIT-FILEPATH: d:\Users\admin\workspace\moon-lol\assets\shaders_extract\environment\unlit_decal\vs\MASKED.vert ---
#version 410

vec3 _36 = vec3(0.0);

struct UniformsVertex
{
    vec4 TERRAIN_XFORM;
    mat4 VIEW_PROJECTION_MATRIX;
    vec4 FOG_OF_WAR_PARAMS;
    vec4 FOG_OF_WAR_ALWAYS_BELOW_Y;
    vec4 FOW_HEIGHT_FADE;
    mat4 DECAL_WORLD_MATRIX;
    mat4 DECAL_WORLD_TO_UV_MATRIX;
    vec4 DECAL_PROJECTION_Y_RANGE;
};

uniform UniformsVertex _UniformsVertex;

layout(location = 0) in vec3 ATTR0;
layout(location = 0) out vec3 TEXCOORD0;
layout(location = 1) out vec2 TEXCOORD1;
layout(location = 2) out vec2 TEXCOORD2;

void main()
{
    precise vec4 _10 = _UniformsVertex.DECAL_WORLD_MATRIX * vec4(ATTR0, 1.0);
    precise vec4 _11 = _UniformsVertex.VIEW_PROJECTION_MATRIX * _10;
    vec4 _51 = _UniformsVertex.DECAL_WORLD_TO_UV_MATRIX * _10;
    vec2 _52 = _51.xz;
    _52.y = 1.0 - _51.z;
    vec3 _56 = vec3(_52.x, _52.y, _36.z);
    float _60 = abs(ATTR0.y - _UniformsVertex.DECAL_PROJECTION_Y_RANGE.x);
    vec3 _74 = vec3(0.0);
    if (_60 <= _UniformsVertex.DECAL_PROJECTION_Y_RANGE.y)
    {
        vec3 _67 = _56;
        _67.z = 1.0;
        _74 = _67;
    }
    else
    {
        vec3 _73 = _56;
        _73.z = 1.0 - ((_60 - _UniformsVertex.DECAL_PROJECTION_Y_RANGE.y) / _UniformsVertex.DECAL_PROJECTION_Y_RANGE.z);
        _74 = _73;
    }
    gl_Position = _11;
    TEXCOORD0 = _74;
    TEXCOORD1 = (_UniformsVertex.TERRAIN_XFORM.xy * _10.xz) + _UniformsVertex.TERRAIN_XFORM.zw;
    TEXCOORD2 = ((_10.xz * _UniformsVertex.FOG_OF_WAR_PARAMS.xy) + _UniformsVertex.FOG_OF_WAR_PARAMS.zw).xy;
}



--- VSCODE-MULTI-EDIT-FILEPATH: d:\Users\admin\workspace\moon-lol\assets\shaders_extract\environment\unlit_decal\vs\MASKED__MULT_PASS.vert ---
#version 410

vec3 _40 = vec3(0.0);

struct UniformsVertex
{
    vec4 TERRAIN_XFORM;
    mat4 VIEW_PROJECTION_MATRIX;
    vec4 FOG_OF_WAR_PARAMS;
    vec4 FOG_OF_WAR_ALWAYS_BELOW_Y;
    vec4 FOW_HEIGHT_FADE;
    mat4 DECAL_WORLD_MATRIX;
    mat4 DECAL_WORLD_TO_UV_MATRIX;
    vec4 DECAL_PROJECTION_Y_RANGE;
    mat4x3 vParticleUVTransformMult;
};

uniform UniformsVertex _UniformsVertex;

layout(location = 0) in vec3 ATTR0;
layout(location = 0) out vec3 TEXCOORD0;
layout(location = 1) out vec4 TEXCOORD1;
layout(location = 2) out vec2 TEXCOORD2;

void main()
{
    precise vec4 _10 = _UniformsVertex.DECAL_WORLD_MATRIX * vec4(ATTR0, 1.0);
    precise vec4 _11 = _UniformsVertex.VIEW_PROJECTION_MATRIX * _10;
    vec4 _55 = _UniformsVertex.DECAL_WORLD_TO_UV_MATRIX * _10;
    vec2 _56 = _55.xz;
    float _58 = 1.0 - _55.z;
    _56.y = _58;
    vec3 _60 = vec3(_56.x, _56.y, _40.z);
    float _64 = abs(ATTR0.y - _UniformsVertex.DECAL_PROJECTION_Y_RANGE.x);
    vec3 _78 = vec3(0.0);
    if (_64 <= _UniformsVertex.DECAL_PROJECTION_Y_RANGE.y)
    {
        vec3 _71 = _60;
        _71.z = 1.0;
        _78 = _71;
    }
    else
    {
        vec3 _77 = _60;
        _77.z = 1.0 - ((_64 - _UniformsVertex.DECAL_PROJECTION_Y_RANGE.y) / _UniformsVertex.DECAL_PROJECTION_Y_RANGE.z);
        _78 = _77;
    }
    vec3 _91 = _UniformsVertex.vParticleUVTransformMult * vec4(_55.x, _58, 1.0, 0.0);
    vec2 _98 = (_UniformsVertex.TERRAIN_XFORM.xy * _10.xz) + _UniformsVertex.TERRAIN_XFORM.zw;
    gl_Position = _11;
    TEXCOORD0 = _78;
    TEXCOORD1 = vec4(_91.x, _91.y, _98.x, _98.y);
    TEXCOORD2 = ((_10.xz * _UniformsVertex.FOG_OF_WAR_PARAMS.xy) + _UniformsVertex.FOG_OF_WAR_PARAMS.zw).xy;
}



--- VSCODE-MULTI-EDIT-FILEPATH: d:\Users\admin\workspace\moon-lol\assets\shaders_extract\environment\unlit_decal\vs\BASE.vert ---
#version 410

vec3 _35 = vec3(0.0);

struct UniformsVertex
{
    mat4 VIEW_PROJECTION_MATRIX;
    vec4 FOG_OF_WAR_PARAMS;
    vec4 FOG_OF_WAR_ALWAYS_BELOW_Y;
    vec4 FOW_HEIGHT_FADE;
    mat4 DECAL_WORLD_MATRIX;
    mat4 DECAL_WORLD_TO_UV_MATRIX;
    vec4 DECAL_PROJECTION_Y_RANGE;
};

uniform UniformsVertex _UniformsVertex;

layout(location = 0) in vec3 ATTR0;
layout(location = 0) out vec3 TEXCOORD0;
layout(location = 1) out vec2 TEXCOORD2;

void main()
{
    precise vec4 _9 = _UniformsVertex.DECAL_WORLD_MATRIX * vec4(ATTR0, 1.0);
    precise vec4 _10 = _UniformsVertex.VIEW_PROJECTION_MATRIX * _9;
    vec4 _50 = _UniformsVertex.DECAL_WORLD_TO_UV_MATRIX * _9;
    vec2 _51 = _50.xz;
    _51.y = 1.0 - _50.z;
    vec3 _55 = vec3(_51.x, _51.y, _35.z);
    float _59 = abs(ATTR0.y - _UniformsVertex.DECAL_PROJECTION_Y_RANGE.x);
    vec3 _73 = vec3(0.0);
    if (_59 <= _UniformsVertex.DECAL_PROJECTION_Y_RANGE.y)
    {
        vec3 _66 = _55;
        _66.z = 1.0;
        _73 = _66;
    }
    else
    {
        vec3 _72 = _55;
        _72.z = 1.0 - ((_59 - _UniformsVertex.DECAL_PROJECTION_Y_RANGE.y) / _UniformsVertex.DECAL_PROJECTION_Y_RANGE.z);
        _73 = _72;
    }
    gl_Position = _10;
    TEXCOORD0 = _73;
    TEXCOORD2 = ((_9.xz * _UniformsVertex.FOG_OF_WAR_PARAMS.xy) + _UniformsVertex.FOG_OF_WAR_PARAMS.zw).xy;
}

写一个 agent，从 BASE.vert 或 BASE.frag 开始，维护一个逆向 shader，将逆向 shader 与其他 shader 文件逐个让 AI 对比，并让 AI 输出新的逆向 shader 来更新逆向 shader，根据文件名的长度逐渐增加来选取下个要对比的文件。
当 AI 生成一个新的 shader 后，对新的 shader 预处理，再让 AI 对比预处理后的 shader 与刚刚被做对比的 shader，对比两个 shader 的变量名和 AST 结构可以不同，但最终的计算结构必须是一致的。如果 AI 得出计算结构一致则进行下一个文件的下一轮对比，如果不一致则重新进行对比生成新的 shader，并且包含不一致的地方的信息。
在经过 2 的 n 次方 - 1 次对比后，得到最终的逆向 shader。整个逆向过程需要记录下来进行持久化，防止工作丢失，就放在 assets/shaders_reverse_history/ 下。

预处理代码为：

use glsl_lang_pp::processor::event::{DirectiveKind, Event};
use glsl_lang_pp::processor::fs::StdProcessor;
use glsl_lang_pp::processor::nodes::{Define, DefineObject};
use glsl_lang_pp::processor::ProcessorState;

pub fn preprocess_glsl(source: &str, conditions: &[&str]) -> String {
    let mut processor = StdProcessor::default();

    let parsed = processor.parse_source(source, "input.glsl".as_ref());

    let mut state_builder = ProcessorState::builder();

    for cond in conditions {
        let parts: Vec<&str> = cond.splitn(2, ' ').collect();
        let name = parts[0];
        let value = if parts.len() > 1 { parts[1] } else { "1" };

        if let Ok(obj) = DefineObject::from_str(value) {
            state_builder = state_builder.definition(Define::object(name.into(), obj, false));
        }
    }

    let state = state_builder.finish();

    let mut output = String::new();

    for event in parsed.process(state) {
        if let Ok(event) = event {
            match event {
                Event::Token { token, masked, .. } => {
                    if !masked {
                        output.push_str(token.text());
                    }
                }
                Event::Directive { directive, masked } => {
                    if !masked {
                        match directive.kind() {
                            DirectiveKind::Version(_)
                            | DirectiveKind::Extension(_)
                            | DirectiveKind::Pragma(_)
                            | DirectiveKind::Line(_) => {
                                output.push_str(&directive.to_string());
                            }
                            _ => {
                                output.push('\n');
                            }
                        }
                    }
                }
                _ => {}
            }
        }
    }

    output
}

